import java.util.Scanner;

public class 과일고르기 {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);
		String[] fruits = { "자몽", "망고", "바나나", "멜론" };
		
		System.out.println("찾고 싶은 과일 : ");
		String fruit = sc.next();

			if (fruit.equals(fruits[0])) {
				System.out.println("자몽의 위치는 1번에 있습니다.");
			}
			else if (fruits.equals(fruits[1])) {
				System.out.println("망고의 위치는 2번에 있습니다.");
			}
			else if (fruit.equals(fruits[2])) {
				System.out.println("바나나의 위치는 3번에 있습니다.");
			} 
			else if(fruit.equals(fruits[3]))
				System.out.println("멜론의 위치는 4번에 있습니다.");

	}
}
되게 단순하다.

사실 단순 출력문으로만 이뤄졌고, 반복이 너무 많아서 코드 짜면서도 이건 좀 아니다 싶었다

결과를 내야했기 때문에 이렇게 썼었는데

​

if문 활용해서 배열 fruits의 인덱스 번호를 저장하고, 입력받은 문자열이 인덱스에 저장된 번호와 

배열의 칸에 맞는 결과가 비교되어 일치 결과가 도출 될 때까지 반복되는 문장으로 만들었어야 했다.

그리고 만약, 배열에 없는 과일이 입력됐을 때의 반환값?을 정했어야 했는데 그것 마저 없음.


import java.util.Scanner;

public class 쪽지시험_06 {

	public static void main(String[] args) {
		// 원하는 과일이 몇 번째에 들어있는 지 출력하는 프로그램
		// 서칭 알고리즘의 기본, sequential search
		String[] fruits = { "자몽", "망고", "바나나", "멜론", "샤인머스캣", "체리" };
		Scanner sc = new Scanner(System.in);
		System.out.print("찾고싶은 과일 : ");
		String input = sc.next();

		// input이 배열의 _번째와 같은지 순차적으로 True/False 확인
		int findIndex = -1; // 인덱스 번호 저장할 변수 선언
		// 찾는 내용이 없을 경우를 대비해 -1로 선언한다.(인덱스 번호는 0부터 시작되기 때문에)
		for (int i = 0; i < fruits.length; i++) {
			// i가 index 안에 들어갈 수 있도록 만들어준다.
			if (input.equals(fruits[i])) { // 총 6번 비교하도록 코드 작성
				findIndex = i; // 같은 과일이 있으면 해당되는 인덱스에 저장되도록 저장
				break;// 프로그램의 효율성을 위해, 목적을 찾으면 프로그램이 종료되도록 break.
			}
		}

		if (findIndex == -1) {
			System.out.println("찾는 과일이 없습니다.");
		} else {
			System.out.println(input + "의 위치는" + (findIndex + 1) + "입니다.");
		}
	}

}
